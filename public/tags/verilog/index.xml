<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Verilog | Navaneet Portfolio</title>
    <link>http://localhost:1313/tags/verilog/</link>
      <atom:link href="http://localhost:1313/tags/verilog/index.xml" rel="self" type="application/rss+xml" />
    <description>Verilog</description>
    <generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><lastBuildDate>Tue, 18 Apr 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>http://localhost:1313/media/icon_hu_645fa481986063ef.png</url>
      <title>Verilog</title>
      <link>http://localhost:1313/tags/verilog/</link>
    </image>
    
    <item>
      <title>ðŸŽ‰ Verilog Codes</title>
      <link>http://localhost:1313/project/verilog/</link>
      <pubDate>Tue, 18 Apr 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/project/verilog/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/sainavaneet/Verilog/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ðŸ‘‰ Developed Verilog HDL code for a 4-bit adder, 4-to-1 multiplexer, AND gate, BUF gate, and an inverter with delay.&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;system-that-generates-detects-and-corrects-hamming-code&#34;&gt;System that generates, detects, and corrects Hamming Code&lt;/h3&gt;
&lt;p&gt;âž” Module implements the Hamming code encoder for each of the 16 input parts.&lt;/p&gt;
&lt;p&gt;âž” Module converts a binary input into separate ASCII characters.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/sainavaneet/system-that-generates-detects-and-corrects-Hamming-Code&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ðŸ‘‰ Developed Verilog HDL code for the system that generates, detects, and corrects Hamming Code.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Verilog code examples that demonstrate various functionalities and designs. Each module is implemented as a separate Verilog file.&lt;/p&gt;
&lt;h2 id=&#34;contents&#34;&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#bintoascii&#34;&gt;bintoascii&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bintoascii_tb&#34;&gt;bintoascii_tb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hamming&#34;&gt;hamming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bintoascii&#34;&gt;bintoascii&lt;/h3&gt;
&lt;p&gt;This module converts a binary input into separate ASCII characters.&lt;/p&gt;
&lt;h4 id=&#34;inputs&#34;&gt;Inputs&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;binary_input&lt;/code&gt; (112 bits): Binary input data.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;outputs&#34;&gt;Outputs&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;part_7790_0&lt;/code&gt; to &lt;code&gt;part_7790_15&lt;/code&gt; (7 bits each): ASCII characters derived from the binary input.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bintoascii_tb&#34;&gt;bintoascii_tb&lt;/h3&gt;
&lt;p&gt;This is a testbench module for the &lt;code&gt;bintoascii&lt;/code&gt; module. It provides stimulus to the module and displays the output ASCII characters.&lt;/p&gt;
&lt;h4 id=&#34;inputs-1&#34;&gt;Inputs&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;binary_input&lt;/code&gt; (112 bits): Binary input data.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;outputs-1&#34;&gt;Outputs&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;part_7790_0&lt;/code&gt; to &lt;code&gt;part_7790_15&lt;/code&gt; (7 bits each): ASCII characters derived from the binary input.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hamming&#34;&gt;hamming&lt;/h3&gt;
&lt;p&gt;This module implements the Hamming code encoder for each of the 16 input parts.&lt;/p&gt;
&lt;h4 id=&#34;inputs-2&#34;&gt;Inputs&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;part_7790_0&lt;/code&gt; to &lt;code&gt;part_7790_15&lt;/code&gt; (7 bits each): Input data for each part.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;outputs-2&#34;&gt;Outputs&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;out_77990_0&lt;/code&gt; to &lt;code&gt;out_77990_15&lt;/code&gt; (11 bits each): Hamming code output for each part.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>32 bit CPU based on MIPS architecture</title>
      <link>http://localhost:1313/project/32-bit-cpu-based-on-mips-architecture/</link>
      <pubDate>Tue, 18 Apr 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/project/32-bit-cpu-based-on-mips-architecture/</guid>
      <description>&lt;p&gt;Implementation of a 32-bit MIPS Processor using Verilog HDL. The processor is capable of executing various MIPS instructions and includes key components such as the Instruction Memory, Register File, ALU, Data Memory, and Control Unit.&lt;/p&gt;
&lt;h2 id=&#34;instruction-set&#34;&gt;Instruction Set&lt;/h2&gt;
&lt;p&gt;The MIPS Processor supports the following instructions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ADD rd, rs, rt&lt;/code&gt;: Reg[rd] = Reg[rs] + Reg[rt]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BNE rs, rt, imm16&lt;/code&gt;: Branch if (Reg[rs] != Reg[rt])&lt;/li&gt;
&lt;li&gt;&lt;code&gt;J target&lt;/code&gt;: Jump to the specified target address&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JR rs&lt;/code&gt;: Jump to the address stored in Reg[rs]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LW rt, imm16(rs)&lt;/code&gt;: Load data from memory to Reg[rt]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SLT rd, rs, rt&lt;/code&gt;: Set Reg[rd] to 1 if (Reg[rs] &amp;lt; Reg[rt]), otherwise 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUB rd, rs, rt&lt;/code&gt;: Reg[rd] = Reg[rs] - Reg[rt]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SW rt, imm16(rs)&lt;/code&gt;: Store data from Reg[rt] to memory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XORI rt, rs, imm16&lt;/code&gt;: Reg[rt] = Reg[rs] XOR Zero_ext(Imm16)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;architecture&#34;&gt;Architecture&lt;/h2&gt;
&lt;p&gt;The MIPS Processor follows a 5-stage pipeline architecture, consisting of the following stages:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Instruction Fetch (IF)&lt;/li&gt;
&lt;li&gt;Instruction Decode (ID)&lt;/li&gt;
&lt;li&gt;Execute (EX)&lt;/li&gt;
&lt;li&gt;Memory Access (MEM)&lt;/li&gt;
&lt;li&gt;Write Back (WB)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Each stage has its own set of registers and performs specific operations to execute the instructions.&lt;/p&gt;
&lt;h2 id=&#34;modules&#34;&gt;Modules&lt;/h2&gt;
&lt;p&gt;The design of the MIPS Processor includes the following modules:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;InstructionMem&lt;/strong&gt;: Stores and retrieves instructions based on the provided address.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RegFile&lt;/strong&gt;: 32-register file module with read and write operations.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Add&lt;/strong&gt;: 32-bit adder module.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ALU&lt;/strong&gt;: 32-bit Arithmetic Logic Unit module for performing arithmetic and logical operations.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DataMem&lt;/strong&gt;: Data memory module for storing and retrieving 32-bit data values.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Control Unit&lt;/strong&gt;: Generates control signals for different stages of the processor pipeline.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ForwardingUnit&lt;/strong&gt;: Solves data hazards in the pipelined processor by forwarding correct data to the ALU input.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mux3x32to32&lt;/strong&gt;: 3x32 to 32 multiplexer module.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mips_32&lt;/strong&gt;: The main module that integrates all the components and implements the 32-bit MIPS Processor.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;testing&#34;&gt;Testing&lt;/h2&gt;
&lt;p&gt;A testbench has been created to verify the functionality of the MIPS Processor. It includes test stimuli and checks the behavior of the processor by observing memory addresses and fetched instructions.&lt;/p&gt;
&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;
&lt;p&gt;To use the MIPS Processor, you can instantiate the &lt;code&gt;mips_32&lt;/code&gt; module in your Verilog design and provide appropriate inputs. Make sure to adhere to the instruction set and connect any required peripherals or memory modules.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
